{
  "hash": "5928bbd07cdddd6009bc80bc2af93627",
  "result": {
    "markdown": "---\ntitle: \"Matrix Algebra in R\"\nauthor: \"YOUR NAME HERE\"\ndate: \"2024-2-14\"\nformat: \n  html:\n    embed-resources: true\n    code-tools: true\n    code-summary: \"Code\"\n---\n\n\nReview the following tutorial on basic matrix algebra in R and complete the exercises at the bottom. Your solutions should include both R code and any output requested. You may organize your solutions using an R Markdown document or in a pdf/docx format.\n\nYou may collaborate with your classmates and consult external resources, but you should write and submit your own answer. **Any classmates with whom you collaborate should be credited at the top of your submission. Similarly, if you consult any external references, you should cite them clearly and explicitly.**\n\n# Preliminaries\n\nIf you have never used R or are a little rusty, consider reviewing the tutorial [here](https://github.com/matloff/fasteR#overview) or the textbook [here](https://r4ds.hadley.nz/whole-game).\n\n# Vectors\n\nIn R, vectors are sets of elements of the same type. We can create vectors using the concatenation function `c()` or by using a function like `numeric()` or `double()` to create a vector of a specific type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(16, 3, 0, 7, -2) # values specified\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16  3  0  7 -2\n```\n:::\n\n```{.r .cell-code}\ny <- numeric(5) # empty numeric vector of length 5.\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0 0 0\n```\n:::\n:::\n\n\nWe index vectors using `[index]` after the vector name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nx[4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\nIf we use a negative index, we return the vector with that element removed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16  3  0 -2\n```\n:::\n:::\n\n\nNote that atomic vectors can only have one type of data. So the following lines work:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- c(\"a\", \"b\", \"c\")\nz <- c(T, F, T)\n```\n:::\n\n\nbut when we try\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, \"b\", 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"b\" \"3\"\n```\n:::\n:::\n\n\nR will force the elements in our vector to be of the same type. This is a common source of bugs.\n\n## Generating vectors\n\nThe notation `a:b` generates integers starting at `a` and ending at `b`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6\n```\n:::\n:::\n\n\nThe `rep` function repeats values of the first argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(\"Hello\", times = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello\" \"Hello\" \"Hello\"\n```\n:::\n:::\n\n\nThe `rnorm` function randomly generates `n` elements with the specified `mean` and `sd`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(n = 10, mean = 1, sd = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  2.60409819  1.33158365  0.79439427  0.64043720  1.76425257 -0.94968076\n [7]  0.97017223  0.05758001  0.92285477  0.33038647\n```\n:::\n:::\n\n\n## Vector operations\n\nOperations involving two vectors of the same length `x` and `y` are typically carried out element-wise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\ny <- 5:8\nx + y # element-wise addition\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6  8 10 12\n```\n:::\n\n```{.r .cell-code}\nx * y # element-wise multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5 12 21 32\n```\n:::\n:::\n\n\nOperations involving a vector and a scalar are typically carried out along the entire vector, recycling the scalar value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\nx + 2 # scalar addition\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 5 6\n```\n:::\n\n```{.r .cell-code}\nx * 2 # scalar multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 8\n```\n:::\n:::\n\n\nThe dot product can be carried out by using element-wise multiplication with the `sum()` function or the `%*%` operator\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\ny <- 5:8\nsum(x * y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 70\n```\n:::\n\n```{.r .cell-code}\nx %*% y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]   70\n```\n:::\n:::\n\n\n\n\n\n## Useful functions for vectors\n\n-   `max()`, `min()`, `mean()`, `median()`, `sum()`, `sd()`, `var()`\n-   `length()` returns the number of elements in the vector\n-   `head()` and `tail()` return the beginning and end vectors\n-   `sort()` will sort\n-   `summary()` returns a 5-number summary\n-   `any()` and `all()` to check conditions on Boolean vectors\n-   `hist()` will return a crude histogram \n\n# Matrices\n\n**Matrices** are two-dimensional extensions of vectors: they have **rows** and **columns**. We can create a matrix using the function `matrix()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 4, 5)\ny <- c(5, 4, 3, 2, 1)\nmy_matrix <- matrix(c(x, y), nrow = 2, ncol = 5, byrow = TRUE)\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    5    4    3    2    1\n```\n:::\n:::\n\n\nWe can also generate matrices by column binding (`cbind()`) and row binding (`rbind()`) vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     x y\n[1,] 1 5\n[2,] 2 4\n[3,] 3 3\n[4,] 4 2\n[5,] 5 1\n```\n:::\n\n```{.r .cell-code}\nrbind(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [,1] [,2] [,3] [,4] [,5]\nx    1    2    3    4    5\ny    5    4    3    2    1\n```\n:::\n:::\n\n\nIndexing a matrix is similar to indexing a vector, except we must index both the row and column, in that order.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    5    4    3    2    1\n```\n:::\n\n```{.r .cell-code}\nmy_matrix[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nAs with vectors, we can subset using a negative index.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    5    4    3    2    1\n```\n:::\n\n```{.r .cell-code}\nmy_matrix[-2, -4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 5\n```\n:::\n\n```{.r .cell-code}\n# Note: Leaving an index blank includes all indices\nmy_matrix[, -c(1, 3, 4, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4\n```\n:::\n:::\n\n\nWhat happened here? When subsetting a matrix reduces one dimension to length 1, R automatically coerces it into a vector. We can prevent this by including `drop = FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix[, -c(1, 3, 4, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4\n```\n:::\n\n```{.r .cell-code}\nis.matrix(my_matrix[, -c(1, 3, 4, 5)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nmy_matrix[, -c(1, 3, 4, 5), drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]    2\n[2,]    4\n```\n:::\n:::\n\n\nWe can also fill in an empty matrix using indices. In R, you should always start by initializing an empty matrix of the right size.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_results <- matrix(NA, nrow = 3, ncol = 3)\nmy_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n[3,]   NA   NA   NA\n```\n:::\n:::\n\n\nThen I can replace a single row (or column) using indices as follows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_results[2, ] <- c(2, 4, 3)\nmy_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    2    4    3\n[3,]   NA   NA   NA\n```\n:::\n:::\n\n\nWe can also fill in multiple rows (or columns) at once. (Likewise, we can also do subsets of rows/columns, or unique entries). Note that values are **recycled**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_results[c(1, 3), ] <- 7\nmy_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    7    7    7\n[2,]    2    4    3\n[3,]    7    7    7\n```\n:::\n:::\n\n\nMatrices, like vectors, can only have entries of one type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrbind(c(1, 2, 3), c(\"a\", \"b\", \"c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,] \"1\"  \"2\"  \"3\" \n[2,] \"a\"  \"b\"  \"c\" \n```\n:::\n:::\n\n\n## Matrix operations\n\nLet's create 3 matrices for the purposes of demonstrating matrix functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n:::\n\n```{.r .cell-code}\nmat2 <- matrix(1:6, nrow = 3, ncol = 2)\nmat2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n:::\n\n```{.r .cell-code}\nmat3 <- matrix(5:10, nrow = 2, ncol = 3, byrow = TRUE)\nmat3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    5    6    7\n[2,]    8    9   10\n```\n:::\n:::\n\n\nFor matrices of the same dimensions, element-wise operations are available:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 + mat3 # element-wise addition\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    6    8   10\n[2,]   12   14   16\n```\n:::\n\n```{.r .cell-code}\nmat1 * mat3 # element-wise multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    5   12   21\n[2,]   32   45   60\n```\n:::\n:::\n\n\nFor matrix multiplication, we use the `%*%` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat_square <- mat1 %*% mat2\nmat_square\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   14   32\n[2,]   32   77\n```\n:::\n:::\n\n\n## Useful functions for matrices\n\n#### Column Bind Matrices `cbind()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(mat1, mat3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    2    3    5    6    7\n[2,]    4    5    6    8    9   10\n```\n:::\n:::\n\n\n#### Transpose `t()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n:::\n:::\n\n\n#### Column Sums `colSums()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 7 9\n```\n:::\n:::\n\n\n#### Row Sums `rowSums()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowSums(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6 15\n```\n:::\n:::\n\n\n#### Column Means `colMeans()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.5 3.5 4.5\n```\n:::\n:::\n\n\n#### Row Means `rowMeans()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowMeans(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 5\n```\n:::\n:::\n\n\n#### Dimensions `dim()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n:::\n\n\n#### Determinant `det()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndet(mat_square)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54\n```\n:::\n:::\n\n\n#### Matrix Inverse `solve()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsolve(mat_square)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]       [,2]\n[1,]  1.4259259 -0.5925926\n[2,] -0.5925926  0.2592593\n```\n:::\n:::\n\n\n#### Matrix Diagonal `diag()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiag(mat_square)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14 77\n```\n:::\n:::\n\n\n#### Matrix Trace `sum(diag())`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(diag(mat_square))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 91\n```\n:::\n:::\n\n\n# Eigenvalues\n\nWe can use the `eigen()` function to compute eigenvalues and eigenvectors of matrices.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat_asym <- matrix(c(1, 0, 2, 1), nrow = 2)\nev <- eigen(mat_asym)\nev$values # eigenvalues\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1\n```\n:::\n\n```{.r .cell-code}\nev$vectors # eigenvectors\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]          [,2]\n[1,]    1 -1.000000e+00\n[2,]    0  1.110223e-16\n```\n:::\n:::\n\n\nNote that eigenvalues and eigenvectors are calculated numerically, so tiny values (very close to zero) may show up in the eigenvectors. The `zapsmall()` function can be useful to replace these with zero. When a matrix is diagonalizable, the eigenvectors will be orthogonal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat_asym <- matrix(c(1, 0, 2, 1), nrow = 2)\nev <- eigen(mat_asym)\nev$values # eigenvalues\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1\n```\n:::\n\n```{.r .cell-code}\nzapsmall(ev$vectors) # eigenvectors\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1   -1\n[2,]    0    0\n```\n:::\n:::\n\n\nIf your matrix is symmetric, you can specify this using `symmetric = TRUE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nev <- eigen(mat_square, symmetric = TRUE)\nev$values # eigenvalues\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 90.4026725  0.5973275\n```\n:::\n\n```{.r .cell-code}\nev$vectors # eigenvectors\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          [,1]       [,2]\n[1,] 0.3863177 -0.9223658\n[2,] 0.9223658  0.3863177\n```\n:::\n:::\n\n\nWhen a matrix is not diagonalizable, the eigenvectors will not be orthogonal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat_asym <- matrix(c(0, 0, 1, 0), byrow = T, nrow = 2)\nev <- eigen(mat_asym)\nev$values # eigenvalues\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0\n```\n:::\n\n```{.r .cell-code}\nzapsmall(ev$vectors) # eigenvectors\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    0    0\n[2,]    1   -1\n```\n:::\n:::\n\n\n\n# Visualization\n\nThe `plot3D` package provides some basic tools for generating static 3D visualizations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\ndata(penguins)\nlibrary(plot3D)\nscatter3D(x = penguins$bill_length_mm, \n          y = penguins$bill_depth_mm, \n          z = penguins$body_mass_g)\n```\n\n::: {.cell-output-display}\n![](matrix-algebra-lab_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\nNote that 3D scatter plots are often difficult to read/interpret. You may often be able to get more effective results using a 2D plane and color as your third variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = body_mass_g)) +\n  geom_point() + \n  scale_color_viridis_c()\n```\n\n::: {.cell-output-display}\n![](matrix-algebra-lab_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\n# Exercises\n\n1. Create a vector `x` containing the integers 1 through 100 and compute the length of `x` by taking the square root of the dot product of `x` with itself.\n\n2. Construct the following matrices in R and use matrix functions/operations to answer the following questions.\n\n$$\nA=\\begin{bmatrix}\n\t\t1 & 2 & 3 & 4 \\\\\n\t\t0 & 1 & 1 & 2 \\\\\n\t\t1 & 3 & 4 & 6 \n\\end{bmatrix}\\hspace{2cm}\nB=\\begin{bmatrix}\n\t\t1 & 1 & 2 \\\\\n\t\t2 & 2 & 4 \\\\\n\t\t5 & 6 & 7 \\\\\n\t\t5 & 6 & 8 \n\\end{bmatrix}\n$$\n\n  a. What is $AB$?\n  b. What is $B^T A^T$?\n  c. Is $AB$ invertible? If so, what is its inverse?\n  d. Is $A^T A$ invertible? If so, what is its inverse?\n  e. Is $B^T B$ invertible? If so, what is its inverse?\n  f. What are the non-zero eigenvalues of $A^T A$? How do they compare to the non-zero eigenvalues of $AA^T$?\n  \n3. Use matrix operations in R to solve the following system of linear equations:\n\n\\begin{align}\n7x+2y+z&=30\\\\\n8x+2y-z&=24\\\\\nx+y+z&=12\n\\end{align}\n\n4. Use a 3d scatter plot to visualize the relationships between the variables `mpg`, `hp`, and `wt` from the `mtcars` dataset (included in R).\n\n\n  \n\n",
    "supporting": [
      "matrix-algebra-lab_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}