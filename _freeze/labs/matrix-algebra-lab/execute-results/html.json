{
  "hash": "8fc7e42835639e5f50067cae238747fb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Matrix Algebra in R\"\nauthor: \"YOUR NAME HERE\"\ndate: \"2025-2-19\"\nformat: \n  html:\n    embed-resources: true\n    code-tools: true\n    code-summary: \"Code\"\ndraft: false\n---\n\n\n\nReview the following tutorial on basic matrix algebra in R and complete the exercises at the bottom. Your solutions should include both R code and any output requested. You may organize your solutions using an R Markdown document or in a pdf/docx format.\n\nYou may collaborate with your classmates and consult external resources, but you should write and submit your own answer. **Any classmates with whom you collaborate should be credited at the top of your submission. Similarly, if you consult any external references, you should cite them clearly and explicitly.**\n\n# Preliminaries\n\nIf you have never used R or are a little rusty, consider reviewing the tutorial [here](https://github.com/matloff/fasteR#overview) or the textbook [here](https://r4ds.hadley.nz/whole-game).\n\n# Vectors\n\nIn R, vectors are sets of elements of the same type. We can create vectors using the concatenation function `c()` or by using a function like `numeric()` or `double()` to create a vector of a specific type.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(16, 3, 0, 7, -2) # values specified\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16  3  0  7 -2\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- numeric(5) # empty numeric vector of length 5.\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 0 0 0 0\n```\n\n\n:::\n:::\n\n\n\nWe index vectors using `[index]` after the vector name:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nx[4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n\nIf we use a negative index, we return the vector with that element removed:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16  3  0 -2\n```\n\n\n:::\n:::\n\n\n\nNote that atomic vectors can only have one type of data. So the following lines work:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- c(\"a\", \"b\", \"c\")\nz <- c(T, F, T)\n```\n:::\n\n\n\nbut when we try\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, \"b\", 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"b\" \"3\"\n```\n\n\n:::\n:::\n\n\n\nR will force the elements in our vector to be of the same type. This is a common source of bugs.\n\n## Generating vectors\n\nThe notation `a:b` generates integers starting at `a` and ending at `b`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5 6\n```\n\n\n:::\n:::\n\n\n\nThe `rep` function repeats values of the first argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(\"Hello\", times = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello\" \"Hello\" \"Hello\"\n```\n\n\n:::\n:::\n\n\n\nThe `rnorm` function randomly generates `n` elements with the specified `mean` and `sd`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(n = 10, mean = 1, sd = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -0.2246169  2.1315710  2.3599192  1.0812675 -0.0785048  1.0471461\n [7]  2.0366317  0.8833474  2.0729662  0.4053206\n```\n\n\n:::\n:::\n\n\n\n## Vector operations\n\nOperations involving two vectors of the same length `x` and `y` are typically carried out element-wise:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\ny <- 5:8\nx + y # element-wise addition\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6  8 10 12\n```\n\n\n:::\n\n```{.r .cell-code}\nx * y # element-wise multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5 12 21 32\n```\n\n\n:::\n:::\n\n\n\nOperations involving a vector and a scalar are typically carried out along the entire vector, recycling the scalar value.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\nx + 2 # scalar addition\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5 6\n```\n\n\n:::\n\n```{.r .cell-code}\nx * 2 # scalar multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 6 8\n```\n\n\n:::\n:::\n\n\n\nThe dot product can be carried out by using element-wise multiplication with the `sum()` function or the `%*%` operator\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\ny <- 5:8\nsum(x * y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 70\n```\n\n\n:::\n\n```{.r .cell-code}\nx %*% y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]   70\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Useful functions for vectors\n\n-   `max()`, `min()`, `mean()`, `median()`, `sum()`, `sd()`, `var()`\n-   `length()` returns the number of elements in the vector\n-   `head()` and `tail()` return the beginning and end vectors\n-   `sort()` will sort\n-   `summary()` returns a 5-number summary\n-   `any()` and `all()` to check conditions on Boolean vectors\n-   `hist()` will return a crude histogram \n\n# Matrices\n\n**Matrices** are two-dimensional extensions of vectors: they have **rows** and **columns**. We can create a matrix using the function `matrix()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 4, 5)\ny <- c(5, 4, 3, 2, 1)\nmy_matrix <- matrix(c(x, y), nrow = 2, ncol = 5, byrow = TRUE)\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    5    4    3    2    1\n```\n\n\n:::\n:::\n\n\n\nWe can also generate matrices by column binding (`cbind()`) and row binding (`rbind()`) vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     x y\n[1,] 1 5\n[2,] 2 4\n[3,] 3 3\n[4,] 4 2\n[5,] 5 1\n```\n\n\n:::\n\n```{.r .cell-code}\nrbind(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [,1] [,2] [,3] [,4] [,5]\nx    1    2    3    4    5\ny    5    4    3    2    1\n```\n\n\n:::\n:::\n\n\n\nIndexing a matrix is similar to indexing a vector, except we must index both the row and column, in that order.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    5    4    3    2    1\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_matrix[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\nAs with vectors, we can subset using a negative index.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    5    4    3    2    1\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_matrix[-2, -4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Note: Leaving an index blank includes all indices\nmy_matrix[, -c(1, 3, 4, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4\n```\n\n\n:::\n:::\n\n\n\nWhat happened here? When subsetting a matrix reduces one dimension to length 1, R automatically coerces it into a vector. We can prevent this by including `drop = FALSE`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix[, -c(1, 3, 4, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4\n```\n\n\n:::\n\n```{.r .cell-code}\nis.matrix(my_matrix[, -c(1, 3, 4, 5)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_matrix[, -c(1, 3, 4, 5), drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    2\n[2,]    4\n```\n\n\n:::\n:::\n\n\n\nWe can also fill in an empty matrix using indices. In R, you should always start by initializing an empty matrix of the right size.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_results <- matrix(NA, nrow = 3, ncol = 3)\nmy_results\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n[3,]   NA   NA   NA\n```\n\n\n:::\n:::\n\n\n\nThen I can replace a single row (or column) using indices as follows.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_results[2, ] <- c(2, 4, 3)\nmy_results\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    2    4    3\n[3,]   NA   NA   NA\n```\n\n\n:::\n:::\n\n\n\nWe can also fill in multiple rows (or columns) at once. (Likewise, we can also do subsets of rows/columns, or unique entries). Note that values are **recycled**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_results[c(1, 3), ] <- 7\nmy_results\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    7    7    7\n[2,]    2    4    3\n[3,]    7    7    7\n```\n\n\n:::\n:::\n\n\n\nMatrices, like vectors, can only have entries of one type.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrbind(c(1, 2, 3), c(\"a\", \"b\", \"c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,] \"1\"  \"2\"  \"3\" \n[2,] \"a\"  \"b\"  \"c\" \n```\n\n\n:::\n:::\n\n\n\n## Matrix operations\n\nLet's create 3 matrices for the purposes of demonstrating matrix functions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n\n\n:::\n\n```{.r .cell-code}\nmat2 <- matrix(1:6, nrow = 3, ncol = 2)\nmat2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n\n```{.r .cell-code}\nmat3 <- matrix(5:10, nrow = 2, ncol = 3, byrow = TRUE)\nmat3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    5    6    7\n[2,]    8    9   10\n```\n\n\n:::\n:::\n\n\n\nFor matrices of the same dimensions, element-wise operations are available:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 + mat3 # element-wise addition\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    6    8   10\n[2,]   12   14   16\n```\n\n\n:::\n\n```{.r .cell-code}\nmat1 * mat3 # element-wise multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    5   12   21\n[2,]   32   45   60\n```\n\n\n:::\n:::\n\n\n\nFor matrix multiplication, we use the `%*%` operator:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat_square <- mat1 %*% mat2\nmat_square\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]   14   32\n[2,]   32   77\n```\n\n\n:::\n:::\n\n\n\n## Useful functions for matrices\n\n#### Column Bind Matrices `cbind()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(mat1, mat3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    2    3    5    6    7\n[2,]    4    5    6    8    9   10\n```\n\n\n:::\n:::\n\n\n\n#### Transpose `t()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n:::\n\n\n\n#### Column Sums `colSums()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 7 9\n```\n\n\n:::\n:::\n\n\n\n#### Row Sums `rowSums()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowSums(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6 15\n```\n\n\n:::\n:::\n\n\n\n#### Column Means `colMeans()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.5 3.5 4.5\n```\n\n\n:::\n:::\n\n\n\n#### Row Means `rowMeans()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowMeans(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 5\n```\n\n\n:::\n:::\n\n\n\n#### Dimensions `dim()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3\n```\n\n\n:::\n:::\n\n\n\n#### Determinant `det()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndet(mat_square)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54\n```\n\n\n:::\n:::\n\n\n\n#### Matrix Inverse `solve()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsolve(mat_square)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]       [,2]\n[1,]  1.4259259 -0.5925926\n[2,] -0.5925926  0.2592593\n```\n\n\n:::\n:::\n\n\n\n#### Matrix Diagonal `diag()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiag(mat_square)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 14 77\n```\n\n\n:::\n:::\n\n\n\n#### Matrix Trace `sum(diag())`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(diag(mat_square))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 91\n```\n\n\n:::\n:::\n\n\n\n# Eigenvalues\n\nWe can use the `eigen()` function to compute eigenvalues and eigenvectors of matrices.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat_asym <- matrix(c(1, 0, 2, 1), nrow = 2)\nev <- eigen(mat_asym)\nev$values # eigenvalues\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\nev$vectors # eigenvectors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]          [,2]\n[1,]    1 -1.000000e+00\n[2,]    0  1.110223e-16\n```\n\n\n:::\n:::\n\n\n\nNote that eigenvalues and eigenvectors are calculated numerically, so tiny values (very close to zero) may show up in the eigenvectors. The `zapsmall()` function can be useful to replace these with zero. When a matrix is diagonalizable, the eigenvectors will be orthogonal.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat_asym <- matrix(c(1, 0, 2, 1), nrow = 2)\nev <- eigen(mat_asym)\nev$values # eigenvalues\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\nzapsmall(ev$vectors) # eigenvectors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1   -1\n[2,]    0    0\n```\n\n\n:::\n:::\n\n\n\nIf your matrix is symmetric, you can specify this using `symmetric = TRUE`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nev <- eigen(mat_square, symmetric = TRUE)\nev$values # eigenvalues\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 90.4026725  0.5973275\n```\n\n\n:::\n\n```{.r .cell-code}\nev$vectors # eigenvectors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]       [,2]\n[1,] 0.3863177 -0.9223658\n[2,] 0.9223658  0.3863177\n```\n\n\n:::\n:::\n\n\n\nWhen a matrix is not diagonalizable, the eigenvectors will not be orthogonal.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat_asym <- matrix(c(0, 0, 1, 0), byrow = T, nrow = 2)\nev <- eigen(mat_asym)\nev$values # eigenvalues\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 0\n```\n\n\n:::\n\n```{.r .cell-code}\nzapsmall(ev$vectors) # eigenvectors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    0    0\n[2,]    1   -1\n```\n\n\n:::\n:::\n\n\n\n\n# Visualization\n\nThe `plot3D` package provides some basic tools for generating static 3D visualizations:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\ndata(penguins)\nlibrary(plot3D)\nscatter3D(x = penguins$bill_length_mm, \n          y = penguins$bill_depth_mm, \n          z = penguins$body_mass_g)\n```\n\n::: {.cell-output-display}\n![](matrix-algebra-lab_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\n\nNote that 3D scatter plots are often difficult to read/interpret. You may often be able to get more effective results using a 2D plane and color as your third variable.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = body_mass_g)) +\n  geom_point() + \n  scale_color_viridis_c()\n```\n\n::: {.cell-output-display}\n![](matrix-algebra-lab_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\n\n# Exercises\n\n1. Create a vector `x` containing the integers 1 through 100 and compute the length of `x` by taking the square root of the dot product of `x` with itself.\n\n2. Construct the following matrices in R and use matrix functions/operations to answer the following questions.\n\n$$\nA=\\begin{bmatrix}\n\t\t1 & 2 & 3 & 4 \\\\\n\t\t0 & 1 & 1 & 2 \\\\\n\t\t1 & 3 & 4 & 6 \n\\end{bmatrix}\\hspace{2cm}\nB=\\begin{bmatrix}\n\t\t1 & 1 & 2 \\\\\n\t\t2 & 2 & 4 \\\\\n\t\t5 & 6 & 7 \\\\\n\t\t5 & 6 & 8 \n\\end{bmatrix}\n$$\n\n  a. What is $AB$?\n  b. What is $B^T A^T$?\n  c. Is $AB$ invertible? If so, what is its inverse?\n  d. Is $A^T A$ invertible? If so, what is its inverse?\n  e. Is $B^T B$ invertible? If so, what is its inverse?\n  f. What are the non-zero eigenvalues of $A^T A$? How do they compare to the non-zero eigenvalues of $AA^T$?\n  \n3. Use matrix operations in R to solve the following system of linear equations:\n\n\\begin{align}\n7x+2y+z&=30\\\\\n8x+2y-z&=24\\\\\nx+y+z&=12\n\\end{align}\n\nThe `usps` dataset in the `Rdimtools` package may be loaded using the following code (be sure to install the `Rdimtools` package first).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Rdimtools)\ndata(usps)\n```\n:::\n\n\n\nThe data consists of a list whose first element is `data`, an 11000 by 256 matrix of numbers between 0 and 255. Each row of this matrix represents a 16 by 16 pixel image of a handwritten digit. For example, if we wish to look at the 1st handwritten digit, we can convert the first row to a 16 by 16 matrix using the following code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(usps$data[1,], nrow=16)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]\n [1,]    0    0    0    0    0    0    0    0    0     0     0     0     0\n [2,]    0    0    0    0    0    0    0    0    0     0     0     0     2\n [3,]    0    0    0    0    0    0    0    0    0     0     0    32   123\n [4,]    0    0    0    0    0    0    0    0    0     0    38   221   255\n [5,]    0    0    0    0    0    0    0    0    0   102   241   255   158\n [6,]    0    0    0    0    0    0    0    4  165   254   255   215    17\n [7,]    0    0    0    0    0    0   31  185  255   252   145    14     0\n [8,]    0    0    0    0    0   91  238  255  255   142     0     0     0\n [9,]    0    0    0    0   39  227  255  232   64     0     0     0     0\n[10,]    0    0    0   40  216  255  219   63    0     0     0     0     0\n[11,]    0    0    4  208  255  251   53    0    0     0     0     0     0\n[12,]    0   11  160  255  245   69    0    0    0     0     0     0     0\n[13,]    0   98  255  255   98    0    0    0    0     0     0     0     0\n[14,]   33  253  255  145    3    0    0    0    0     0     0     0     0\n[15,]  121  255  204    3    0    0    0    0    0     0     0     0     0\n[16,]   68  157   28    0    0    0    0    0    0     0     0     0     0\n      [,14] [,15] [,16]\n [1,]    12   151   101\n [2,]   114   242    54\n [3,]   255   202    13\n [4,]   208    18     0\n [5,]    15     0     0\n [6,]     0     0     0\n [7,]     0     0     0\n [8,]     0     0     0\n [9,]     0     0     0\n[10,]     0     0     0\n[11,]     0     0     0\n[12,]     0     0     0\n[13,]     0     0     0\n[14,]     0     0     0\n[15,]     0     0     0\n[16,]     0     0     0\n```\n\n\n:::\n:::\n\n\n\nOr the 4000th digit:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(usps$data[4000,], nrow=16)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]\n [1,]    0    0    0    0    0    0    0    0    0     0     0     0    53\n [2,]    0    0    0    0    0    0    0    0    0     0     0   102   252\n [3,]    0    0    0    0    0    0    0    0    0     0    54   248   139\n [4,]    0    0    0    6  160  168    0    0    0    15   222   195     8\n [5,]    0    0    7  169  251   72    0    0    7   177   247    45     0\n [6,]    0    6  200  255  157    0    0    0   95   255   149     0     0\n [7,]    1  165  255  138    0    0    0   18  208   232    17     0     0\n [8,]  101  255  250  156  146  146  146  188  255   209   146   104    73\n [9,]   74  145  173  218  218  185  185  255  222   145   145   145   145\n[10,]    0    0    0    0    0    0   61  255  100     0     0     0     0\n[11,]    0    0    0    0    0    0  156  213   12     0     0     0     0\n[12,]    0    0    0    0    0   51  248   82    0     0     0     0     0\n[13,]    0    0    0    0    0  151  206    0    0     0     0     0     0\n[14,]    0    0    0    0   16  231   87    0    0     0     0     0     0\n[15,]    0    0    0    0  146  151    0    0    0     0     0     0     0\n[16,]    0    0    0   12  157    8    0    0    0     0     0     0     0\n      [,14] [,15] [,16]\n [1,]   178   114     0\n [2,]   120    13     0\n [3,]     0     0     0\n [4,]     0     0     0\n [5,]     0     0     0\n [6,]     0     0     0\n [7,]     0     0     0\n [8,]    73    73    49\n [9,]   145    97    73\n[10,]     0     0     0\n[11,]     0     0     0\n[12,]     0     0     0\n[13,]     0     0     0\n[14,]     0     0     0\n[15,]     0     0     0\n[16,]     0     0     0\n```\n\n\n:::\n:::\n\n\n\nThe `image()` function can be used to plot this matrix as an image (with the argument `col = gray.colors(256, start = 1, end = 0)` to ensure it is black and white). However, as seen below the orientation is a little bit off.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimage(matrix(usps$data[4000,], nrow=16), \n      col = gray.colors(256, start = 1, end = 0))\n```\n\n::: {.cell-output-display}\n![](matrix-algebra-lab_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\n\n4. Use the `image()` function to plot the above number in the correct orientation. You will need to transform the matrix.\n\n5. The second object contained in the `usps` list is called `label` and contains a vector describing which digit each row is. What does the \"average\" 0 look like? We can get an idea by taking all of the rows corresponding to 0s, computing the element-wise (pixel-wise) average, and then transforming the resulting vector into a 16 by 16 pixel. The resulting image is called the **centroid** of the zero digits. Use the `image()` function to plot the centroids of each digit (in the correct orientation). You may notice something odd...\n\n  \n\n",
    "supporting": [
      "matrix-algebra-lab_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}